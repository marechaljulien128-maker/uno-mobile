<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>UNO Firebase Complet & Robuste</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* Styles généraux */
        body { font-family: 'Segoe UI', sans-serif; text-align: center; background-color: #2c3e50; color: white; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        /* Conteneur principal du jeu (caché par défaut) */
        #game-container { display: none; flex-direction: column; flex-grow: 1; }

        /* Styles existants */
        #game-info { padding: 10px; background: #34495e; }
        #status { font-weight: bold; color: #f1c40f; }
        #table { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; }
        .card-pile { width: 80px; height: 120px; border-radius: 8px; border: 3px solid white; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; background: #95a5a6; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        #hand-container { height: 160px; background: #222; overflow-x: auto; display: flex; align-items: center; padding: 0 10px; gap: 5px; }
        .card { 
            min-width: 70px; height: 110px; border-radius: 6px; display: flex; align-items: center; justify-content: center; 
            font-weight: bold; font-size: 20px; color: white; cursor: pointer; border: 2px solid #fff; position: relative;
            transition: transform 0.2s;
        }
        .card:hover { transform: translateY(-10px); }
        .Rouge { background: #e74c3c; }
        .Bleu { background: #3498db; }
        .Vert { background: #2ecc71; }
        .Jaune { background: #f1c40f; color: black; }
        .Noire { background: #2c3e50; border: 2px dashed white; } /* Dos de carte et Joker/Wild */
        button { background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 20px; font-size: 16px; margin-top: 10px; cursor: pointer; }
        button:disabled { background: #7f8c8d; }
        #controls { margin: 10px; }
        #opponents { display: flex; justify-content: space-around; width: 100%; padding: 10px; }
        .opponent { text-align: center; }
        .uno-button-container { display: flex; justify-content: center; margin-top: 10px; }
        .uno-button-container button { margin: 0 10px; }
        .card-animation {
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
            position: absolute;
            z-index: 10; /* Au-dessus des autres cartes */
        }

        /* Sélection de couleur (pour les Jokers) */
        #color-select {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none; /* Caché par défaut */
            z-index: 100;
            color: #333;
        }

        #color-select.show {
            display: block;
        }

        #color-select button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 5px;
            border: none;
            cursor: pointer;
        }

        /* Style pour la sélection du salon */
        #room-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1; /* Prend tout l'espace disponible */
            padding: 20px;
        }
        #room-selection label {
            display: block;
            margin-bottom: 5px;
            font-size: 1.2em;
        }
        #room-selection input[type="text"] {
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #ccc;
            width: 250px;
            margin-bottom: 15px;
            font-size: 1em;
            color: #333;
        }
        #room-selection button {
            background-color: #2980b9;
            padding: 12px 25px;
            font-size: 1.1em;
            border-radius: 25px;
        }
        /* Styles pour la liste des salons disponibles */
        #available-rooms-container {
            margin-top: 30px;
            width: 80%;
            max-width: 400px;
            background-color: #34495e;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            max-height: 300px;
            overflow-y: auto;
        }
        #available-rooms-container h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.3em;
            color: #ecf0f1;
        }
        #available-rooms-ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .room-item {
            background-color: #2c3e50;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: left;
            font-size: 1.1em;
        }
        .room-item:hover {
            background-color: #3a536b;
        }
        .room-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>

    <!-- Sélection du salon -->
    <div id="room-selection">
        <label for="room-id">Nom du salon:</label>
        <input type="text" id="room-id" placeholder="Entrez un nom de salon">
        <button onclick="joinRoom()">Rejoindre ou Créer</button>

        <div id="available-rooms-container">
            <h2>Salons disponibles</h2>
            <ul id="available-rooms-ul">
                <li>Chargement des salons...</li>
            </ul>
        </div>
    </div>

    <!-- Conteneur principal du jeu -->
    <div id="game-container">
        <div id="game-info">
            <div>Joueurs connectés: <span id="player-count">0</span></div>
            <div id="status">Chargement...</div>
        </div>

        <!-- Affichage du nombre de cartes des adversaires -->
        <div id="opponents">
            <!-- Rempli dynamiquement par JavaScript -->
        </div>

        <div id="table">
            <!-- La défausse -->
            <div id="discard-pile" class="card-pile">?</div>
            
            <div id="controls">
                <button id="btn-draw" onclick="drawCard()">Piocher</button>
                <button id="btn-end-turn" onclick="endTurn()" style="display:none; background-color: #f39c12;">Passer mon tour</button>
                <button id="btn-start" onclick="startGame()" style="display:none; background-color: #e67e22;">Démarrer la partie</button>
                <button id="btn-quit" onclick="quitGame()" style="background-color: #c0392b;">Quitter la partie</button>
            </div>

            <!-- Boutons UNO / Contre-UNO -->
           <div class="uno-button-container">
                <button id="btn-uno" onclick="callUno()" disabled>UNO</button>
                <button id="btn-counter-uno" onclick="counterUno()" disabled>Contre UNO</button>
            </div>
        </div>

        <div id="hand-container">
            <!-- Les cartes du joueur iront ici -->
        </div>
    </div>

    <!-- Sélection de couleur (pour les Jokers) -->
    <div id="color-select">
        <p>Choisir une couleur :</p>
        <button style="background-color: #e74c3c;" onclick="setColor('Rouge')"></button>
        <button style="background-color: #3498db;" onclick="setColor('Bleu')"></button>
        <button style="background-color: #2ecc71;" onclick="setColor('Vert')"></button>
        <button style="background-color: #f1c40f;" onclick="setColor('Jaune')"></button>
    </div>

    <!-- Import Firebase Modular SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove, onDisconnect, get } 
        from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

        // ------------------------------------------------------------------
        // CONFIGURATION FIREBASE (A REMPLACER PAR LA VOTRE)
        // ------------------------------------------------------------------
        const firebaseConfig = {
          apiKey: "AIzaSyC8muWc77SYBV9IKdltyW2s_2-vz6Seu7M",
          authDomain: "uno-mobile-d506d.firebaseapp.com",
          databaseURL: "https://uno-mobile-d506d-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "uno-mobile-d506d",
          storageBucket: "uno-mobile-d506d.firebasestorage.app",
          messagingSenderId: "505946389294",
          appId: "1:505946389294:web:38720c49913319b7a798bf",
          measurementId: "G-14ZHV63WTD"
        };

        // Initialisation Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // Identifiant unique local pour ce joueur
        let myId = localStorage.getItem('uno_player_id');
        if (!myId) {
            myId = 'player_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('uno_player_id', myId);
        }

        let ROOM_ID = null;
        let gameRef = null; // Référence à la salle de jeu
        let playersRef = null; // Référence aux joueurs de la salle
        let myPlayerRef = null; // Référence à mon joueur
        let gameState = null;
        let cardBeingPlayed = null; // Stocke la carte en cours de jeu (pour les Jokers/choix de couleur)
        let cardBeingPlayedIndex = null; // Index de la carte jouée pour l'animation

        // --- GESTION DES SALONS DISPONIBLES ---
        function setupAvailableRoomsListener() {
            const allGamesRef = ref(db, 'games');
            onValue(allGamesRef, (snapshot) => {
                const availableRoomsUl = document.getElementById('available-rooms-ul');
                availableRoomsUl.innerHTML = ''; // Effacer la liste précédente

                const roomsData = snapshot.val();
                if (roomsData) {
                    Object.keys(roomsData).forEach(roomId => {
                        const li = document.createElement('li');
                        li.className = 'room-item'; // Pour le style CSS
                        li.textContent = roomId;
                        li.onclick = () => {
                            document.getElementById('room-id').value = roomId; // Pré-remplir l'input
                            joinRoom(roomId); // Tenter de rejoindre ce salon
                        };
                        availableRoomsUl.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    li.textContent = "Aucun salon disponible pour l'instant.";
                    availableRoomsUl.appendChild(li);
                }
            });
        }
        setupAvailableRoomsListener(); // Initialiser l'écouteur au chargement de la page

        // --- GESTION DU SALON ACTUEL ---
        window.joinRoom = function(prefilledRoomId = null) {
            const roomIdInput = document.getElementById('room-id');
            const newRoomId = prefilledRoomId || roomIdInput.value.trim();

            if (!newRoomId) {
                alert("Veuillez entrer un nom de salon.");
                return;
            }

            // Si on change de salon, ou qu'on rejoignait un salon précédemment,
            // il serait bon de nettoyer les anciens listeners.
            // Pour l'instant, on s'assure juste que les `onValue` sont attachés à la bonne référence.
            // Firebase gère assez bien le remplacement des listeners sur la même référence.

            ROOM_ID = newRoomId;
            gameRef = ref(db, 'games/' + ROOM_ID);
            playersRef = ref(db, `games/${ROOM_ID}/players`);
            myPlayerRef = ref(db, `games/${ROOM_ID}/players/${myId}`);

            // Enregistrer le joueur et configurer onDisconnect
            set(myPlayerRef, {
                name: "Joueur " + myId.substr(0,4),
                active: true,
                unoCalled: false, // État de l'annonce UNO
                hasDrawnThisTurn: false // État de la pioche pour ce tour
            }).then(() => {
                onDisconnect(myPlayerRef).remove().then(() => {
                    // La logique de nettoyage du salon est dans onValue(playersRef, ...)
                });
                console.log(`Connecté au salon : ${ROOM_ID} en tant que ${myId}`);
                setupGameListeners(); // Mettre en place les listeners spécifiques au jeu pour CE salon
                document.getElementById('room-selection').style.display = 'none';
                document.getElementById('game-container').style.display = 'flex';
            }).catch(error => {
                console.error("Erreur de connexion au salon:", error);
                alert("Impossible de se connecter au salon. Veuillez réessayer.");
            });
        };

        function setupGameListeners() {
            // Listener principal sur l'état du jeu
            onValue(gameRef, (snapshot) => {
                gameState = snapshot.val();
                
                if (!gameState || !gameState.started) {
                    document.getElementById('status').innerText = "En attente de lancement...";
                }

                // Vérifier si la partie est terminée (par exemple, un gagnant)
                if (gameState && gameState.winner) {
                    alert(`La partie est terminée ! ${gameState.players[gameState.winner].name} a gagné !`);
                    // Optionnel: Réinitialiser la partie ou déconnecter tout le monde
                    // set(gameRef, null); // Supprimer la salle après victoire si c'est la fin du jeu
                }

                renderGame();
            });

            // Listener spécifique pour les joueurs afin de déclencher le nettoyage du salon
            onValue(playersRef, (snapshot) => {
                const playersData = snapshot.val();
                if (!playersData || Object.keys(playersData).length === 0) {
                    console.log(`Le salon ${ROOM_ID} est vide, suppression...`);
                    remove(gameRef)
                        .then(() => {
                            console.log(`Salon ${ROOM_ID} supprimé.`);
                            // Réinitialiser l'interface pour la sélection de salon
                            ROOM_ID = null;
                            gameRef = null;
                            playersRef = null;
                            myPlayerRef = null;
                            gameState = null;
                            document.getElementById('game-container').style.display = 'none';
                            document.getElementById('room-selection').style.display = 'flex';
                            document.getElementById('room-id').value = '';
                            alert("Le salon est vide et a été fermé.");
                            setupAvailableRoomsListener(); // Réactualiser la liste des salons
                        })
                        .catch(error => console.error("Erreur lors de la suppression du salon:", error));
                }
            });
        }

        // --- FONCTIONS DU JEU ---
        
        window.startGame = function() {
            if (!gameState || gameState.started) return; // Ne pas démarrer si déjà démarré
            const players = gameState.players || {};
            const pIds = Object.keys(players);
            if (pIds.length < 2) {
                alert("Il faut au moins 2 joueurs pour démarrer une partie !");
                return;
            }

            // Générer le deck
            const colors = ['Rouge', 'Bleu', 'Vert', 'Jaune'];
            const standardValues = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+2', 'Sens', 'Passe'];
            let deck = [];
            
            colors.forEach(c => {
                standardValues.forEach(v => {
                    deck.push({ color: c, value: v });
                    if(v !== '0') deck.push({ color: c, value: v }); // Deux fois sauf le 0
                });
            });
            
            // Ajouter les Jokers et +4 (4 de chaque)
            for (let i = 0; i < 4; i++) {
                deck.push({ color: 'Noire', value: 'Joker' });
                deck.push({ color: 'Noire', value: '+4' });
            }
            
            // Mélanger
            deck.sort(() => Math.random() - 0.5);

            let updates = {};
            pIds.forEach(pid => {
                updates[`players/${pid}/hand`] = deck.splice(0, 7);
                updates[`players/${pid}/unoCalled`] = false; // Réinitialiser le UNO
                updates[`players/${pid}/hasDrawnThisTurn`] = false; // Réinitialiser l'état de pioche
            });

            // Piocher la première carte de la défausse
            let firstDiscardCard = deck.shift(); // Utiliser shift pour prendre la première
            // Assurer que la première carte n'est pas un joker (+4 ou Joker simple)
            while (firstDiscardCard && (firstDiscardCard.value === '+4' || firstDiscardCard.value === 'Joker')) {
                deck.push(firstDiscardCard); // Remettre à la fin du deck
                deck.sort(() => Math.random() - 0.5); // Remélanger
                firstDiscardCard = deck.shift(); // Piocher une nouvelle carte
            }

            updates['deck'] = deck;
            updates['discard'] = firstDiscardCard;
            updates['discardPile'] = []; // Initialiser la pile de défausse
            updates['currentTurn'] = pIds[0]; // Le premier commence
            updates['order'] = pIds; // Ordre du tour
            updates['started'] = true;
            updates['direction'] = 1; // 1 = horaire, -1 = anti-horaire
            updates['unoChallenged'] = null; // Personne n'a contesté le UNO

            update(gameRef, updates);
        };

        window.drawCard = function() {
            // Un joueur ne peut piocher que si c'est son tour et qu'il n'a pas déjà pioché ce tour
            if (!isMyTurn() || gameState.players[myId].hasDrawnThisTurn || document.getElementById('color-select').classList.contains('show')) {
                console.log("Impossible de piocher.");
                return;
            }
            
            let updates = {};
            let deck = gameState.deck || [];
            let myNewHand = gameState.players[myId].hand || [];
            
            if (deck.length === 0) {
                deck = recycleDiscardPile(); // Recycler et récupérer le nouveau deck
                if (deck.length === 0) {
                    alert("Plus de cartes dans le deck ou la défausse pour piocher !");
                    return;
                }
            }
            
            const card = deck.shift(); // Piocher la première carte du deck
            myNewHand.push(card);

            updates['deck'] = deck;
            updates[`players/${myId}/hand`] = myNewHand;
            updates[`players/${myId}/hasDrawnThisTurn`] = true; // Indiquer que le joueur a pioché

            update(gameRef, updates)
                .then(() => {
                    console.log("Carte piochée, le joueur peut maintenant la jouer ou passer son tour.");
                    // Le tour ne passe PAS ici, le joueur doit jouer ou passer explicitement
                })
                .catch(error => console.error("Erreur lors de la pioche:", error));
        };

        window.playCard = function(index) {
            if (!isMyTurn() || document.getElementById('color-select').classList.contains('show')) return;

            cardBeingPlayed = gameState.players[myId].hand[index];
            cardBeingPlayedIndex = index; // Pour l'animation
            const topCard = gameState.discard;

            if (isValidPlay(cardBeingPlayed, topCard)) {
                if (cardBeingPlayed.color === 'Noire') {
                    document.getElementById('color-select').classList.add('show');
                    // La fonction setColor() appellera playCardAction() après le choix de couleur
                } else {
                    playCardAction(cardBeingPlayed, cardBeingPlayedIndex);
                }
            } else {
                alert("Carte invalide ! Vous ne pouvez jouer ni la couleur ni la valeur de la carte du dessus.");
            }
        };

        // Fonction appelée après la sélection de couleur pour les jokers
        window.setColor = function(color) {
            document.getElementById('color-select').classList.remove('show');
            if (cardBeingPlayed) {
                // La carte jouée est une carte noire, on lui attribue la couleur choisie pour la défausse
                cardBeingPlayed.chosenColor = color; 
                playCardAction(cardBeingPlayed, cardBeingPlayedIndex);
            }
        };

        function isValidPlay(card, topCard) {
            if (card.color === 'Noire') return true; // Joker toujours valide
            // Si la carte du dessus a une "chosenColor" (pour les jokers précédents)
            const currentTopColor = topCard.chosenColor || topCard.color;
            return card.color === currentTopColor || card.value === topCard.value;
        }

        function playCardAction(card, originalIndex) {
            let updates = {};
            let myCurrentHand = gameState.players[myId].hand;
            let myNewHand = [...myCurrentHand];

            // --- Vérification pour l'alerte UNO ---
            if (myCurrentHand.length === 2) { // Si le joueur a 2 cartes et en joue une
                alert("ATTENTION : Il vous reste 1 carte ! Pensez à dire UNO !");
            }
            // --- Fin vérification UNO ---

            myNewHand.splice(originalIndex, 1); // Retirer la carte jouée de la main

            // Ajouter la carte jouée à la pile de défausse "historique"
            let discardPileHistory = gameState.discardPile || [];
            discardPileHistory.push(gameState.discard); // L'ancienne carte de défausse

            // La nouvelle carte de défausse
            let newDiscardCard = {...card}; // Copie pour ne pas modifier l'originale de la main
            if (card.chosenColor) { // Si c'était un joker et qu'une couleur a été choisie
                newDiscardCard.color = card.chosenColor; // La carte jouée prend la couleur choisie
            } else if (card.color === 'Noire') { // Si un joker est joué sans couleur choisie (bug)
                 newDiscardCard.chosenColor = 'Noire'; // Pour que le rendu sache que c'était un joker, même sans choix explicite
            }


            updates[`players/${myId}/hand`] = myNewHand;
            updates[`players/${myId}/unoCalled`] = false; // Réinitialiser le statut UNO après avoir joué une carte
            updates[`players/${myId}/hasDrawnThisTurn`] = false; // Réinitialiser l'état de pioche
            updates['discard'] = newDiscardCard;
            updates['discardPile'] = discardPileHistory;

            let nextPlayerId = getNextPlayerId(gameState.currentTurn); // Joueur après moi
            let finalNextPlayerId = nextPlayerId; // Le joueur dont c'est le tour final

            // Appliquer les effets de la carte
            switch (card.value) {
                case '+2':
                    applyDrawPenalty(nextPlayerId, 2, updates);
                    finalNextPlayerId = getNextPlayerId(nextPlayerId); // Saute le joueur qui a pioché
                    break;
                case 'Passe':
                    finalNextPlayerId = getNextPlayerId(nextPlayerId); // Saute le joueur suivant
                    break;
                case 'Sens':
                    updates['direction'] = gameState.direction * -1; // Inverser la direction
                    // Re-calculer le prochain joueur après l'inversion
                    finalNextPlayerId = getNextPlayerId(gameState.currentTurn, updates['direction']);
                    break;
                case '+4':
                    applyDrawPenalty(nextPlayerId, 4, updates);
                    finalNextPlayerId = getNextPlayerId(nextPlayerId); // Saute le joueur qui a pioché
                    break;
                // Joker n'a pas d'effet immédiat sur le tour ou la pioche, seulement sur la couleur
            }

            // Vérifier la victoire
            if (myNewHand.length === 0) {
                updates['winner'] = myId;
                updates['started'] = false; // Arrête la partie
            }
            // Mettre à jour le prochain tour
            updates['currentTurn'] = finalNextPlayerId;

            animateCardMovement(originalIndex); // Effet visuel (simplifié)

            update(gameRef, updates)
                .then(() => {
                    cardBeingPlayed = null; // Réinitialiser après avoir joué
                    cardBeingPlayedIndex = null;
                })
                .catch(error => console.error("Erreur lors du jeu de la carte:", error));
        }

        window.endTurn = function() {
            if (!isMyTurn() || !gameState.players[myId].hasDrawnThisTurn || document.getElementById('color-select').classList.contains('show')) {
                alert("Vous ne pouvez pas passer votre tour maintenant.");
                return;
            }

            let updates = {};
            updates[`players/${myId}/hasDrawnThisTurn`] = false; // Réinitialiser l'état de pioche
            updates['currentTurn'] = getNextPlayerId(gameState.currentTurn); // Passer le tour
            
            update(gameRef, updates)
                .then(() => console.log("Tour passé après pioche."))
                .catch(error => console.error("Erreur lors du passage de tour:", error));
        };


        // Applique la pénalité de pioche en mettant à jour l'objet `updates`
        function applyDrawPenalty(targetPlayerId, amount, updates) {
            let deck = gameState.deck || [];
            let targetPlayerHand = gameState.players[targetPlayerId].hand || [];

            for (let i = 0; i < amount; i++) {
                if (deck.length === 0) {
                    deck = recycleDiscardPile(); // Recycler
                    if (deck.length === 0) {
                        console.warn("Plus de cartes dans le deck ou la défausse pour la pénalité !");
                        break;
                    }
                }
                targetPlayerHand.push(deck.shift()); // Piocher du DEBUT du deck
            }
            updates['deck'] = deck;
            updates[`players/${targetPlayerId}/hand`] = targetPlayerHand;
        }


        window.quitGame = function() {
            if (myPlayerRef) {
                remove(myPlayerRef)
                    .then(() => {
                        localStorage.removeItem('uno_player_id');
                        location.reload(); // Recharge la page
                    })
                    .catch(error => console.error("Erreur lors de la déconnexion:", error));
            } else {
                location.reload(); // Si pas connecté à un salon, juste recharger
            }
        };

        window.callUno = function() {
            if (gameState && gameState.players[myId].hand.length === 1 && !gameState.players[myId].unoCalled) {
                update(myPlayerRef, { unoCalled: true })
                    .then(() => alert("Vous avez dit UNO !"))
                    .catch(error => console.error("Erreur lors de l'appel UNO:", error));
            } else {
                alert("Vous ne pouvez pas dire UNO maintenant.");
            }
        };

        window.counterUno = function() {
            // On ne peut pas contre-UNO si c'est notre tour
            if (isMyTurn()) {
                alert("Vous ne pouvez pas vous Contre-UNO vous-même !");
                return;
            }
            if (!gameState || gameState.unoChallenged) return; // Déjà contesté ou pas d'état de jeu

            const previousPlayerId = getPreviousPlayerId();
            const previousPlayer = gameState.players[previousPlayerId];

            if (previousPlayer && previousPlayer.hand && previousPlayer.hand.length === 1 && !previousPlayer.unoCalled) {
                alert("Contre-UNO réussi ! " + previousPlayer.name + " pioche 2 cartes.");
                let updates = {};
                applyDrawPenalty(previousPlayerId, 2, updates);
                updates['unoChallenged'] = myId; // Enregistrer qui a contesté
                update(gameRef, updates);
            } else {
                alert("Contre-UNO invalide !");
            }
        };

        // --- LOGIQUE INTERNE ---

        function isMyTurn() {
            return gameState && gameState.currentTurn === myId;
        }

        function getNextPlayerId(currentTurnId, currentDirection = gameState.direction) {
            const order = gameState.order;
            const currentIndex = order.indexOf(currentTurnId);
            let nextIndex = (currentIndex + currentDirection + order.length) % order.length;
            return order[nextIndex];
        }

        function getPreviousPlayerId(currentDirection = gameState.direction) {
            const order = gameState.order;
            const currentIndex = order.indexOf(gameState.currentTurn); // Le joueur qui vient de jouer
            // Le joueur "précédent" est celui qui, dans le sens inverse du jeu, précède le joueur actuel.
            // Si la direction est 1 (horaire), le précédent est à l'index -1.
            // Si la direction est -1 (anti-horaire), le précédent est à l'index +1.
            let previousIndex = (currentIndex - currentDirection + order.length) % order.length;
            return order[previousIndex];
        }


        function recycleDiscardPile() {
            let currentDiscardCard = gameState.discard;
            let discardPile = gameState.discardPile || [];
            let deck = gameState.deck || [];

            if (discardPile.length === 0) {
                console.warn("Pile de défausse vide pour le recyclage.");
                return deck; // Rien à recycler
            }

            // Récupérer toutes les cartes de la défausse pour les mélanger (sauf la carte du dessus qui reste sur la pile)
            let cardsToRecycle = discardPile;
            
            // Mélanger
            cardsToRecycle.sort(() => Math.random() - 0.5);
            deck = deck.concat(cardsToRecycle); // Ajouter au deck existant

            // Mettre à jour Firebase avec le nouveau deck et la pile de défausse vide
            update(gameRef, {
                deck: deck,
                discardPile: [] // La pile de défausse est maintenant vide
            });
            console.log("Défausse recyclée dans le deck.");
            return deck; // Retourner le nouveau deck
        }

        function renderGame() {
            if (!gameState) {
                document.getElementById('status').innerText = "En attente de lancement...";
                document.getElementById('btn-start').style.display = 'none';
                document.getElementById('btn-draw').disabled = true;
                document.getElementById('btn-end-turn').style.display = 'none';
                document.getElementById('btn-uno').disabled = true;
                document.getElementById('btn-counter-uno').disabled = true;
                return;
            }

            // Mise à jour du compteur de joueurs
            const players = gameState.players || {};
            const playerIds = Object.keys(players);
            document.getElementById('player-count').innerText = playerIds.length;

            // Afficher bouton start seulement si pas commencé et au moins 2 joueurs
            if (!gameState.started && playerIds.length >= 2) {
                document.getElementById('btn-start').style.display = 'inline-block';
            } else {
                document.getElementById('btn-start').style.display = 'none';
            }

            // Afficher la défausse
            const discardDiv = document.getElementById('discard-pile');
            const topCard = gameState.discard;
            if (topCard) {
                // Utiliser la couleur choisie si elle existe, sinon la couleur de la carte
                const displayColor = topCard.chosenColor || topCard.color; 
                discardDiv.className = `card-pile ${displayColor}`;
                discardDiv.innerText = topCard.value;
            } else {
                discardDiv.className = `card-pile`;
                discardDiv.innerText = "?";
            }

            // Afficher le statut et activer les contrôles
            const statusDiv = document.getElementById('status');
            const myPlayerState = gameState.players[myId];
            const isMyCurrentTurn = isMyTurn();

            if (isMyCurrentTurn) {
                statusDiv.innerText = "C'EST À TOI DE JOUER !";
                statusDiv.style.color = "#2ecc71";
                document.body.style.border = "5px solid #2ecc71";
                document.getElementById('btn-draw').disabled = myPlayerState.hasDrawnThisTurn; // Désactiver pioche si déjà pioché
                document.getElementById('btn-end-turn').style.display = myPlayerState.hasDrawnThisTurn ? 'inline-block' : 'none';
            } else {
                const currentPlayerName = gameState.players[gameState.currentTurn]?.name || "un joueur";
                statusDiv.innerText = `Tour de ${currentPlayerName}...`;
                statusDiv.style.color = "#f1c40f";
                document.body.style.border = "none";
                document.getElementById('btn-draw').disabled = true;
                document.getElementById('btn-end-turn').style.display = 'none';
            }
            
            // Afficher ma main
            const handContainer = document.getElementById('hand-container');
            handContainer.innerHTML = '';
            
            const myHand = myPlayerState?.hand || [];
            myHand.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.color}`;
                cardEl.innerText = card.value;
                // Les cartes ne sont cliquables que si c'est mon tour et que je n'attends pas une couleur
                cardEl.onclick = (isMyCurrentTurn && !document.getElementById('color-select').classList.contains('show')) ? () => window.playCard(index) : null;
                cardEl.style.cursor = (isMyCurrentTurn && !document.getElementById('color-select').classList.contains('show')) ? 'pointer' : 'default';
                handContainer.appendChild(cardEl);
            });

            // Activer/désactiver le bouton UNO
            const btnUno = document.getElementById('btn-uno');
            // Le joueur ne peut appeler UNO que si c'est son tour, qu'il a une seule carte et n'a pas encore appelé UNO
            btnUno.disabled = !(isMyCurrentTurn && myHand.length === 1 && !myPlayerState.unoCalled);
            
            // Activer/désactiver le bouton Contre-UNO
            const btnCounterUno = document.getElementById('btn-counter-uno');
            // Le bouton Contre-UNO est activé si ce n'est PAS mon tour, et que personne n'a déjà contesté ce UNO
            btnCounterUno.disabled = (isMyCurrentTurn || gameState.unoChallenged != null);

            renderOpponents();
        }

        function renderOpponents() {
            const opponentsDiv = document.getElementById('opponents');
            opponentsDiv.innerHTML = ''; // Vider

            const players = gameState.players || {};
            const playerIds = gameState.order || Object.keys(players); // Utiliser l'ordre du jeu
            
            playerIds.forEach(playerId => {
                if (playerId !== myId) {
                    const player = players[playerId];
                    if (!player) return; // Le joueur pourrait être déconnecté entre temps

                    const opponentDiv = document.createElement('div');
                    opponentDiv.className = 'opponent';
                    let opponentStatus = '';
                    if (gameState.currentTurn === playerId) {
                        opponentStatus = ' (À JOUER)';
                        opponentDiv.style.fontWeight = 'bold';
                        opponentDiv.style.color = '#fff';
                    } else if (player.unoCalled) {
                        opponentStatus = ' (UNO !)';
                        opponentDiv.style.color = '#f1c40f'; // Couleur jaune pour UNO
                    }
                    opponentDiv.innerHTML = `
                        ${player.name}${opponentStatus}<br>
                        Cartes: ${player.hand ? player.hand.length : 0}
                    `;
                    opponentsDiv.appendChild(opponentDiv);
                }
            });
        }

        function animateCardMovement(index) {
            const cardElement = document.querySelector(`#hand-container > div:nth-child(${index + 1})`);

            if (!cardElement) return;

            // Position de départ (carte dans la main)
            const startRect = cardElement.getBoundingClientRect();

            // Position d'arrivée (pile de défausse)
            const discardPile = document.getElementById('discard-pile');
            const endRect = discardPile.getBoundingClientRect();

            // Créer une copie de la carte pour l'animation
            const animatedCard = cardElement.cloneNode(true);
            animatedCard.classList.add('card-animation');
            animatedCard.style.position = 'fixed'; // Utiliser fixed pour s'assurer qu'elle suit le viewport
            animatedCard.style.left = `${startRect.left}px`;
            animatedCard.style.top = `${startRect.top}px`;
            animatedCard.style.margin = '0'; // Supprimer les marges héritées
            document.body.appendChild(animatedCard);

            // Forcer un repaint pour que la transition fonctionne
            animatedCard.offsetWidth;

            // Appliquer la transformation
            animatedCard.style.transform = `translate(${endRect.left - startRect.left}px, ${endRect.top - startRect.top}px)`;
            animatedCard.style.opacity = '0';

            // Supprimer la carte animée après la transition
            setTimeout(() => {
                animatedCard.remove();
            }, 500);
        }
    </script>
</body>
</html>