<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>UNO Firebase + Complet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* Styles (inchangés, sauf ajustements mineurs) */
        body { font-family: 'Segoe UI', sans-serif; text-align: center; background-color: #2c3e50; color: white; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #game-info { padding: 10px; background: #34495e; }
        #status { font-weight: bold; color: #f1c40f; }
        #table { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; }
        .card-pile { width: 80px; height: 120px; border-radius: 8px; border: 3px solid white; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; background: #95a5a6; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        #hand-container { height: 160px; background: #222; overflow-x: auto; display: flex; align-items: center; padding: 0 10px; gap: 5px; }
        .card { 
            min-width: 70px; height: 110px; border-radius: 6px; display: flex; align-items: center; justify-content: center; 
            font-weight: bold; font-size: 20px; color: white; cursor: pointer; border: 2px solid #fff; position: relative;
            transition: transform 0.2s;
        }
        .card:hover { transform: translateY(-10px); }
        .Rouge { background: #e74c3c; }
        .Bleu { background: #3498db; }
        .Vert { background: #2ecc71; }
        .Jaune { background: #f1c40f; color: black; }
        .Noire { background: #2c3e50; border: 2px dashed white; } /* Dos de carte */
        button { background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 20px; font-size: 16px; margin-top: 10px; cursor: pointer; }
        button:disabled { background: #7f8c8d; }
        #controls { margin: 10px; }
        #opponents { display: flex; justify-content: space-around; width: 100%; padding: 10px; }
        .opponent { text-align: center; }
        .uno-button-container { display: flex; justify-content: center; margin-top: 10px; }
        .uno-button-container button { margin: 0 10px; }
        .card-animation {
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
            position: absolute;
            z-index: 10; /* Au-dessus des autres cartes */
        }

        /* Nouvelles règles CSS pour la sélection de couleur */
        #color-select {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none; /* Caché par défaut */
            z-index: 100;
        }

        #color-select.show {
            display: block;
        }

        #color-select button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 5px;
            border: none;
            cursor: pointer;
        }

        /* Style pour la sélection du salon */
        #room-selection {
            padding: 20px;
            background-color: #34495e;
            margin-bottom: 20px;
        }
        #room-selection label {
            display: block;
            margin-bottom: 5px;
        }
        #room-selection input[type="text"] {
            padding: 8px;
            border-radius: 5px;
            border: none;
            width: 200px;
            margin-bottom: 10px;
        }
        #room-selection button {
            background-color: #2980b9;
        }
    </style>
</head>
<body>

    <!-- Sélection du salon -->
    <div id="room-selection">
        <label for="room-id">Nom du salon:</label>
        <input type="text" id="room-id" placeholder="Entrez un nom de salon">
        <button onclick="joinRoom()">Rejoindre le salon</button>
    </div>

    <div id="game-info">
        <div>Joueurs connectés: <span id="player-count">0</span></div>
        <div id="status">Chargement...</div>
    </div>

    <!-- Affichage du nombre de cartes des adversaires -->
    <div id="opponents">
        <!-- Rempli dynamiquement par JavaScript -->
    </div>

    <div id="table">
        <!-- La défausse -->
        <div id="discard-pile" class="card-pile">?</div>
        
        <div id="controls">
            <button id="btn-draw" onclick="drawCard()">Piocher</button>
            <button id="btn-start" onclick="startGame()" style="display:none; background-color: #e67e22;">Démarrer la partie</button>
            <button id="btn-quit" onclick="quitGame()" style="background-color: #c0392b;">Quitter la partie</button>
        </div>

        <!-- Boutons UNO / Contre-UNO -->
       <div class="uno-button-container">
            <button id="btn-uno" onclick="callUno()" disabled>UNO</button>
            <button id="btn-counter-uno" onclick="counterUno()" disabled>Contre UNO</button>
        </div>
    </div>

    <div id="hand-container">
        <!-- Les cartes du joueur iront ici -->
    </div>

    <!-- Sélection de couleur (pour les Jokers) -->
    <div id="color-select">
        <p>Choisir une couleur :</p>
        <button style="background-color: #e74c3c;" onclick="setColor('Rouge')"></button>
        <button style="background-color: #3498db;" onclick="setColor('Bleu')"></button>
        <button style="background-color: #2ecc71;" onclick="setColor('Vert')"></button>
        <button style="background-color: #f1c40f;" onclick="setColor('Jaune')"></button>
    </div>

    <!-- Import Firebase Modular SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, push, remove, onDisconnect } 
        from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

        // ------------------------------------------------------------------
        // CONFIGURATION FIREBASE (A REMPLACER PAR LA VOTRE)
        // ------------------------------------------------------------------
        const firebaseConfig = {
          apiKey: "AIzaSyC8muWc77SYBV9IKdltyW2s_2-vz6Seu7M",
          authDomain: "uno-mobile-d506d.firebaseapp.com",
          databaseURL: "https://uno-mobile-d506d-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "uno-mobile-d506d",
          storageBucket: "uno-mobile-d506d.firebasestorage.app",
          messagingSenderId: "505946389294",
          appId: "1:505946389294:web:38720c49913319b7a798bf",
          measurementId: "G-14ZHV63WTD"
        };

        // Initialisation
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // Identifiant unique local pour ce téléphone
        let myId = localStorage.getItem('uno_player_id');
        if (!myId) {
            myId = 'player_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('uno_player_id', myId);
        }

        let ROOM_ID = null; // Le salon est défini lors de la connexion
        let gameRef = null;
        let gameState = null;
        let myHand = [];
        let unoCalled = false;
        let cardBeingPlayed = null; // Stocke la carte en cours de jeu (pour les Jokers)

        // --- GESTION DU SALON ---
        window.joinRoom = function() {
            const roomIdInput = document.getElementById('room-id');
            ROOM_ID = roomIdInput.value.trim();

            if (!ROOM_ID) {
                alert("Veuillez entrer un nom de salon.");
                return;
            }

            gameRef = ref(db, 'games/' + ROOM_ID);
            setupGameListeners();
            document.getElementById('room-selection').style.display = 'none'; // Cacher la sélection
        };

        function setupGameListeners() {
            // --- GESTION DE LA CONNEXION ---
            const playerRef = ref(db, `games/${ROOM_ID}/players/${myId}`);
            set(playerRef, {
                name: "Joueur " + myId.substr(0,4),
                active: true,
                unoCalled: false
            });

            onDisconnect(playerRef).remove().then(() => {
                // Nettoyer le salon si plus personne
                cleanupRoom();
            });

            // --- ECOUTER LES MISES A JOUR DE LA DATABASE ---
            onValue(gameRef, (snapshot) => {
                gameState = snapshot.val();

                if (!gameState) {
                    document.getElementById('status').innerText = "En attente de lancement...";
                    document.getElementById('btn-start').style.display = 'inline-block';
                    return;
                }

                // Mise à jour du compteur de joueurs
                const players = gameState.players || {};
                const playerIds = Object.keys(players);
                document.getElementById('player-count').innerText = playerIds.length;

                // Afficher bouton start seulement si pas commencé et au moins 2 joueurs
                if (!gameState.started && playerIds.length >= 2) {
                    document.getElementById('btn-start').style.display = 'inline-block';
                } else {
                    document.getElementById('btn-start').style.display = 'none';
                }

                if (gameState.started) {
                    renderGame();
                }
            });
        }

        // --- FONCTIONS DU JEU (Exportées globalement pour les onclick HTML) ---
        
        window.startGame = function() {
            // Générer le deck
            const colors = ['Rouge', 'Bleu', 'Vert', 'Jaune'];
            const values = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+2', 'Sens', 'Passe']; // Sans Joker ici
            let deck = [];
            
            colors.forEach(c => values.forEach(v => {
                deck.push({ color: c, value: v });
                if(v !== '0') deck.push({ color: c, value: v }); // Deux fois sauf le 0
            }));
            
            // Ajouter les Jokers et +4 (4 de chaque)
            for (let i = 0; i < 4; i++) {
                deck.push({ color: 'Noire', value: 'Joker' });
                deck.push({ color: 'Noire', value: '+4' });
            }
            
            // Mélanger
            deck.sort(() => Math.random() - 0.5);

            // Distribuer
            get(ref(db, `games/${ROOM_ID}/players`)).then((snap) => {
                const players = snap.val();
                const pIds = Object.keys(players);
                let updates = {};

                pIds.forEach(pid => {
                    updates[`games/${ROOM_ID}/players/${pid}/hand`] = deck.splice(0, 7);
                    updates[`games/${ROOM_ID}/players/${pid}/unoCalled`] = false; // Réinitialiser le UNO
                });

                const firstCard = deck.pop();
                
                updates[`games/${ROOM_ID}/deck`] = deck;
                updates[`games/${ROOM_ID}/discard`] = firstCard;
                updates[`games/${ROOM_ID}/currentTurn`] = pIds[0]; // Le premier commence
                updates[`games/${ROOM_ID}/order`] = pIds; // Ordre du tour
                updates[`games/${ROOM_ID}/started`] = true;
                updates[`games/${ROOM_ID}/direction`] = 1; // 1 = horaire, -1 = anti-horaire
                updates[`games/${ROOM_ID}/unoChallenged`] = null; // Personne n'a contesté le UNO

                update(ref(db), updates);
            });
        };

        window.drawCard = function() {
            if (!isMyTurn()) return;
            
            const deck = gameState.deck || [];
            if(deck.length === 0) {
                // Mélanger la défausse (sauf la carte du dessus) et la remettre comme deck
                recycleDiscardPile();
                return; // Réessayer après le mélange
            }

            const card = deck.pop();
            let myNewHand = gameState.players[myId].hand || [];
            myNewHand.push(card);

            update(ref(db, `games/${ROOM_ID}`), {
                deck: deck,
                [`players/${myId}/hand`]: myNewHand
            }).then(() => nextTurn());
        };

        window.playCard = function(index) {
            if (!isMyTurn()) return;

            const card = gameState.players[myId].hand[index];
            const topCard = gameState.discard;

            // Vérification de la validité de la carte
            if (isValidPlay(card, topCard)) {
                cardBeingPlayed = card; // Stocker la carte pour les jokers

                if (card.color === 'Noire') {
                    // Joker ou +4 : afficher la sélection de couleur
                    document.getElementById('color-select').classList.add('show');
                    return; // Attendre que le joueur choisisse une couleur
                } else {
                    // Jouer la carte normalement
                    playCardAction(index, null);
                }
            } else {
                alert("Carte invalide !");
            }
        };

        // Fonction pour jouer la carte APRES avoir choisi la couleur (pour les jokers)
        window.setColor = function(color) {
            document.getElementById('color-select').classList.remove('show');
            playCardAction(null, color); // Pas d'index ici, on sait qu'on joue `cardBeingPlayed`
        };

        function isValidPlay(card, topCard) {
            if (card.color === 'Noire') return true; // Joker toujours valide
            return card.color === topCard.color || card.value === topCard.value;
        }

        function playCardAction(index, chosenColor) {
            let card = cardBeingPlayed;

            if (index !== null) {
                card = gameState.players[myId].hand[index];
            }

            let newHand = [...gameState.players[myId].hand];
            if (index !== null) {
                newHand.splice(index, 1);
            } else {
                // Trouver l'index de `cardBeingPlayed` (car on ne l'a pas)
                const cardIndex = newHand.findIndex(c => c.color === card.color && c.value === card.value);
                if (cardIndex === -1) {
                    console.error("Carte à jouer non trouvée dans la main !");
                    return;
                }
                newHand.splice(cardIndex, 1);
            }

            let updates = {};
            updates[`games/${ROOM_ID}/discard`] = card;

            // Appliquer les effets de la carte
            let nextPlayer = nextTurn(); // Obtenir le joueur suivant (mais ne pas l'appliquer tout de suite)

            switch (card.value) {
                case '+2':
                    drawPenaltyCards(nextPlayer, 2);
                    nextPlayer = nextTurn(); // Sauter le joueur qui pioche
                    break;
                case 'Passe':
                    nextPlayer = nextTurn(); // Sauter le joueur suivant
                    break;
                case 'Sens':
                    updates[`games/${ROOM_ID}/direction`] *= -1; // Inverser la direction
                    break;
                case '+4':
                    drawPenaltyCards(nextPlayer, 4);
                    nextPlayer = nextTurn(); // Sauter le joueur qui pioche
                    break;
                case 'Joker':
                    // La couleur est déjà choisie via setColor()
                    card.color = chosenColor; // Mettre à jour la couleur du joker
                    break;
            }

            updates[`games/${ROOM_ID}/players/${myId}/hand`] = newHand;
            updates[`games/${ROOM_ID}/players/${myId}/unoCalled`] = false; // Reset UNO

            if (newHand.length === 0) {
                updates[`games/${ROOM_ID}/winner`] = myId;
                updates[`games/${ROOM_ID}/started`] = false; // Reset
                alert("Gagné !");
            }
            else if(newHand.length === 1 && !unoCalled) {
                alert("N'oublie pas de dire UNO!");
            }

            animateCardMovement(index); // Effet visuel (simplifié)

            // Appliquer le prochain tour APRES les effets
            updates[`games/${ROOM_ID}/currentTurn`] = nextPlayer;

            update(ref(db), updates).then(() => {
                cardBeingPlayed = null; // Réinitialiser
            });
        }

        window.quitGame = function() {
            remove(ref(db, `games/${ROOM_ID}/players/${myId}`)).then(() => {
                // Réinitialiser l'état local
                localStorage.removeItem('uno_player_id');
                location.reload(); // Recharge la page
            });
        };

        window.callUno = function() {
            unoCalled = true;
            update(ref(db, `games/${ROOM_ID}/players/${myId}`, { unoCalled: true }));
        };

        window.counterUno = function() {
            if (gameState.unoChallenged) return; // Déjà contesté

            const previousPlayerId = findPreviousPlayer();
            const previousPlayer = gameState.players[previousPlayerId];

            if (previousPlayer && previousPlayer.hand && previousPlayer.hand.length === 1 && !previousPlayer.unoCalled) {
                // Contre-UNO valide
                alert("Contre-UNO réussi ! " + previousPlayer.name + " pioche 2 cartes.");
                drawPenaltyCards(previousPlayerId, 2);
                update(gameRef, { unoChallenged: myId });
            } else {
                alert("Contre-UNO invalide !");
            }
        };

        // --- LOGIQUE INTERNE ---

        function isMyTurn() {
            return gameState.currentTurn === myId;
        }

        function nextTurn() {
            const order = gameState.order;
            const currentIndex = order.indexOf(gameState.currentTurn);
            let nextIndex = (currentIndex + gameState.direction + order.length) % order.length; // Gérer la direction
            return order[nextIndex];
        }

        function findPreviousPlayer() {
            const order = gameState.order;
            const currentIndex = order.indexOf(myId);
            const previousIndex = (currentIndex - gameState.direction + order.length) % order.length;
            return order[previousIndex];
        }

        function drawPenaltyCards(playerId, amount) {
            let deck = gameState.deck || [];
            let playerHand = gameState.players[playerId].hand || [];

            for (let i = 0; i < amount; i++) {
                if (deck.length === 0) {
                    recycleDiscardPile();
                    deck = gameState.deck; // Récupérer le deck recyclé
                    if(deck.length === 0) break; // Si toujours vide, on arrête
                }
                playerHand.push(deck.pop());
            }

            update(ref(db, `games/${ROOM_ID}`), {
                deck: deck,
                [`players/${playerId}/hand`]: playerHand
            });
        }

        function recycleDiscardPile() {
            const discardPile = gameState.discard;
            let deck = gameState.deck || [];

            // Récupérer toutes les cartes de la défausse SAUF la dernière carte jouée
            const discardPileCards = Object.assign([], gameState.discardPile || []);

            if(discardPile){
                discardPileCards.push(discardPile);
            }

            if (discardPileCards.length > 0) {
                // Mélanger les cartes de la défausse
                discardPileCards.sort(() => Math.random() - 0.5);

                // Ajouter les cartes mélangées au deck
                deck = deck.concat(discardPileCards);
            }

            update(ref(db, `games/${ROOM_ID}`), {
                deck: deck,
                discardPile: null,
                discard: discardPile // Remettre la carte du dessus
            });
        }

        function cleanupRoom() {
            get(ref(db, `games/${ROOM_ID}/players`)).then((snapshot) => {
                const players = snapshot.val();
                if (!players || Object.keys(players).length === 0) {
                    // Plus de joueurs, on peut supprimer le salon
                    remove(gameRef);
                }
            });
        }

        function renderGame() {
            // Afficher la défausse
            const discardDiv = document.getElementById('discard-pile');
            const topCard = gameState.discard;
            discardDiv.className = `card-pile ${topCard.color}`;
            discardDiv.innerText = topCard.value;

            // Afficher le statut
            const statusDiv = document.getElementById('status');
            if (isMyTurn()) {
                statusDiv.innerText = "C'EST À TOI DE JOUER !";
                statusDiv.style.color = "#2ecc71";
                document.body.style.border = "5px solid #2ecc71";
            } else {
                statusDiv.innerText = "Tour de l'adversaire...";
                statusDiv.style.color = "#f1c40f";
                document.body.style.border = "none";
            }

            // Afficher ma main
            const handContainer = document.getElementById('hand-container');
            handContainer.innerHTML = '';
            
            const myHand = gameState.players[myId].hand || [];
            myHand.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.color}`;
                cardEl.innerText = card.value;
                cardEl.onclick = () => window.playCard(index); // Appel global
                handContainer.appendChild(cardEl);
            });

             // Activer/désactiver le bouton UNO
            const btnUno = document.getElementById('btn-uno');
            if (myHand.length === 1 && !unoCalled) {
                btnUno.disabled = false;
            } else {
                btnUno.disabled = true;
            }
            // Activer/désactiver le bouton Contre-UNO
            const btnCounterUno = document.getElementById('btn-counter-uno');
            btnCounterUno.disabled = !gameState.unoChallenged; // Seulement si quelqu'un a dit UNO

            renderOpponents();
        }

        function renderOpponents() {
            const opponentsDiv = document.getElementById('opponents');
            opponentsDiv.innerHTML = ''; // Vider

            const players = gameState.players || {};
            for (const playerId in players) {
                if (playerId !== myId) {
                    const player = players[playerId];
                    const opponentDiv = document.createElement('div');
                    opponentDiv.className = 'opponent';
                    opponentDiv.innerHTML = `
                        ${player.name}<br>
                        Cartes: ${player.hand ? player.hand.length : 0}
                    `;
                    opponentsDiv.appendChild(opponentDiv);
                }
            }
        }

        function animateCardMovement(index) {
            const cardElement = document.querySelector(`#hand-container > div:nth-child(${index + 1})`);

            if (!cardElement) return;

            // Position de départ (carte dans la main)
            const startRect = cardElement.getBoundingClientRect();

            // Position d'arrivée (pile de défausse)
            const discardPile = document.getElementById('discard-pile');
            const endRect = discardPile.getBoundingClientRect();

            // Créer une copie de la carte pour l'animation
            const animatedCard = cardElement.cloneNode(true);
            animatedCard.classList.add('card-animation');
            animatedCard.style.position = 'absolute';
            animatedCard.style.left = `${startRect.left}px`;
            animatedCard.style.top = `${startRect.top}px`;
            document.body.appendChild(animatedCard);

            // Forcer un repaint pour que la transition fonctionne
            animatedCard.offsetWidth;

            // Appliquer la transformation
            animatedCard.style.transform = `translate(${endRect.left - startRect.left}px, ${endRect.top - startRect.top}px)`;
            animatedCard.style.opacity = '0';

            // Supprimer la carte animée après la transition
            setTimeout(() => {
                animatedCard.remove();
            }, 500);
        }
    </script>
</body>
</html>